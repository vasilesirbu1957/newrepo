<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title> Chebyshev Filter </title>

  <!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->

    <style>
  	  body { margin: 0; }
    </style>
  </head>
  <body>
  <!-- the styles for this page in the local file main.css (in the /static/ directory mandatory!!!)-->
  <!-- <link href="/static/css/main.css" rel="stylesheet" type="text/css"> -->
<!--
  <div>
    <table style="width:100%">
      <tr>
        <th>
          <img id='image01' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-1.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image02' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-2.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image03' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-3.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image04' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-4.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image05' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-5.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image06' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-6.jpg'  height=128 width=128/>
        </th>
        <th>
          <video id='video1' crossOrigin = "Anonymous" autoplay muted loop src='https://raw.githubusercontent.com/vasilesirbu1957/newrepo/main/video1.mov' type="video/mp4" width="128" height="128">
        </th>
        <th>
          <video id='video2' crossOrigin = "Anonymous" autoplay muted loop src='./video1.mov' type="video/mp4"  width="128" height="128">
        </th>
      </tr>
    </table>
  </div>
  -->
  <!-- the main.js module of our 3d application for this page -->
  <script type="module" crossOrigin = "Anonymous" >

  import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/build/three.module.js';
  import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/examples/jsm/controls/OrbitControls.js';
  import {createSkyboxFlowersScene,
          createHemisphereLight,
          createDirectionalLight,
          createPerspectiveCamera} from 'https://raw.githack.com/vasilesirbu1957/newrepo/main/js/scenes.js';

  function main() {
  //   'use strict';
    const canvas = document.querySelector('#myCanvas');
    const renderer = new THREE.WebGLRenderer({canvas},{ antialias: true });
    renderer.physicallyCorrectLights = true;
    renderer.setSize(window.innerWidth, window.innerWidth * 0.5); //square size width=100%, height=50% of width

  const scene = createSkyboxFlowersScene(); //create a skybox scene
/*
    //camera
    const fov = 35;    // camera field of view in degrees
    const aspect = 2;  // the canvas default aspect ratio = 2
    const near =0.1;  // the camera near distance (frustrum start)
    const far = 60;    // the camera far distance (frustrum end)
*/
    const camera = createPerspectiveCamera({fov:35, aspect:2, near:0.1, far:60, x:0, y:0, z:9}, scene);

    // put the camera on a pole (parent it to an object)
    // so we can spin the pole to move the camera around the scene
    /*
    const cameraPole = new THREE.Object3D();
    scene.add(cameraPole);
    cameraPole.add(camera);
    */

    // orbit controls  - rotate and zoom in/out
    const controls = new OrbitControls(camera, canvas);
    controls.target.set(0, 0, 0); //move the scene up (to -0.5 on Y coord)
    controls.update();
       //limit zoom in and out when using THREE.OrbitControls with perspective camera:
    controls.minDistance = 5.0;
    controls.maxDistance = 60.0;
    //limit zoom in and out when using THREE.OrbitControls with ortographic camera:
    //controls.minZoom = 2.0;
    //controls.maxZoom = 40.0;


    //hemisphere light to have light from everywhere
    const Hlight = createHemisphereLight({skyColor:0xFFFFFF, groundColor:0xB97A20, intensity:3}, scene);

    //directional light to have light from the given direction
    const Dlight = createDirectionalLight({color:0xFFFFFF, intensity:3, x:0, y:0, z:5}, camera);

function getpolepair(fc,lh,pr,np,p){
  //fc the cutoff frequency in range 0 - 0.5 of sampling frequency; for a cutoff frequency of 0.1*sf  just enter fc=0.1
  //lh indicates the filter type: lh=0 low pass filter, lh=1 - high pass filter
  //pr indicates the percent ripple in range 0-29 that corresponds to 9-29% ripple in the passband
  //np the number of poles (even number from 2 to 20)
  //p is the poles pair number from 0 to np/2

  let c={a0:0,a1:0,a2:0,b1:0,b2:0};// the coefficients for the current poles pair will be kept here
  let rp,ip;//real and imaginary parts of poles
  let es,vx,kx,t,w,m,d,k;
  let x0,x1,x2,y1,y2;
  //calculate the pole pair location on the unit circle
  rp=-Math.cos(Math.PI/(2*np)+(p-1)*Math.PI/np);//the pole real part on the unit circle
  ip= Math.sin(Math.PI/(2*np)+(p-1)*Math.PI/np);//the pole imaginary part

  if (pr>0){//if ripple is allowed then warp from the unit circle to an ellipse
    es=Math.sqrt((100/(100-pr))**2-1);
    vx=(1/np)*Math.log((1/es)+Math.sqrt((1/es)**2+1));
    kx=(1/np)*Math.log((1/es)+Math.sqrt((1/es)**2-1));
    kx=(Math.exp(kx)+Math.exp(-kx))/2;
    rp=rp*((Math.exp(vx)-Math.exp(-vx))/2)/kx;
    ip=ip*((Math.exp(vx)+Math.exp(-vx))/2)/kx;
  }

  //s-domain to z-domain conversion
  t=2*Math.tan(0.5);
  w=2*Math.PI*fc;
  m=rp**2+ip**2;//(pole module)**2;
  d=4-4*rp*t+m*t**2;
  x0=(t**2)/d;
  x1=2*(t**2)/d;
  x2=(t**2)/d;
  y1=(8-2*m*t**2)/d;
  y2=(-4-4*rp*t-m*t**2)/d;

  //Lowpass to lopass or lowpass to highpass transform
  if (lh==1) {k=-Math.cos(w/2+1/2)/Math.cos(w/2-1/2)}
  else if (lh==0) {k=Math.sin(1/2-w/2)/Math.sin(1/2+w/2)};
  d=1+y1*k-y2*k**2;
  c.a0=(x0-x1*k+x2*k**2)/d;
  c.a1=(-2*x0*k+x1+x1*k**2-2*x2*k)/d;
  c.a2=(x0*k**2-x1*k+x2)/d;
  c.b1=(2*k+y1+y1*k**2-2*y2*k)/d;
  c.b2=(-(k**2)-y1*k+y2)/d;
  if (lh==1){
    c.a1=-c.a1;
    c.b1=-c.b1;
  }

  return c;
}

const printcoeff=0;//=1;

function chebyshev1IIR(fc,lh,pr,np){
  //fc - cutoff frequency 0.0-0.5;
  //lh=0 low pass filter, lh=1 - high pass filter
  //pr - percent ripple 0-29
  //np - number of poles (even number from 2 to 20)
if (printcoeff) console.log('------------fc=',fc,'lh=',lh,'pr=',pr,'np=',np);

  let a=[]; //a[0] ,...a[21] coefficients
  let b=[]; //b[1] ,...b[21] coefficients
  let ta=[]; //0-21
  let tb=[]; //0-21
  for (let i=0; i<23; i++) {
    a[i]=0;
    b[i]=0;
  }
  a[2]=1;
  b[2]=1;
  //let c={a0:0,a2:0,a2:0,b1:0,b2:0};
  for (let p=1; p<np/2+1; p++){//loop for each pole pair
    let c = getpolepair(fc,lh,pr,np,p);

    for (let i=0;i<23;i++){
      ta[i]=a[i];
      tb[i]=b[i];
    }
    for (let i=2;i<23;i++){
      a[i]=c.a0*ta[i]+c.a1*ta[i-1]+c.a2*ta[i-2];
      b[i]=tb[i]-c.b1*tb[i-1]-c.b2*tb[i-2];
      //b[i]=tb[i]+c.b1*tb[i-1]+c.b2*tb[i-2];//b[i]=tb[i]-c.b1*tb[i-1]-c.b2*tb[i-2];
    }
  }
  b[2]=0;
  for (let i=0;i<21;i++) {//shifting the coefficients
    a[i]=a[i+2];
    b[i]=b[i+2];
  }
  let sa=0; //normalize the gain
  let sb=0;
  for (let i=0; i<21; i++) {
    if (lh==0) { //low pass
      sa=sa+a[i];
      sb=sb+b[i];
    } else if (lh==1){//high pass
      sa=sa+a[i]*(-1)**i;
      sb=sb+b[i]*(-1)**i;
    }
  }
  let gain=sa/(1+sb);//let gain=sa/(1-sb);
  for(let i=0;i<21;i++){
    a[i]=a[i]/gain;
  }
if (printcoeff) console.log('------------sa=',sa,'sb=',sb,'a=',a,'b=',b);
return {a,b}
}




    const fd=512;//1024;  //sampling rate, Hz

    const buflen=512; //signal buffer length - even!!!

    const canvas1_height = 512; //canvas height
    //const ym1 = canvas1_height/2;
    const canvas_height = 256; //canvas height
    const ym=canvas_height/2;
    const canvas_width = 534;//1080;   //canvas width

    const signal_ampl = 40;//canvas_height/2-5-max_noise_ampl;
    const max_noise_ampl=2*signal_ampl;// 200%
    var noise_ampl=max_noise_ampl;//50;

    const isin=[];  //signal without noise
    const isign=[]; //signal with noise


    var f=(5/100)*fd; //signal frequency, Hz
    for (let i = 0; i < buflen; i++) isin[i] = signal_ampl*Math.cos(2*Math.PI*i*f/fd); //fill the signal buffer without noise

    const x=[];
    const y=[];
    const sp=[];

    const num_coeff=4;//number of b coefficients (b[1],,...b[num_coef]) num_coef <= 20
    const a=[0.1335566, 0.5342263, 0.8013394, 0.5342263, 0.1335566]; //filter a[i] coefficients
    const b=[0, -0.3904486, -0.6784138, -0.01412021, -0.05392238]; //filter b[i] coefficients


    function filterIsignBuf(){//result will be in isignf
      let fc=displayFilterParamsrect.getCurrentValue(2)/100;//fraction of fc in the range 0-0.5
      let lh=displayFilterParamsrect.getCurrentValue(3);//0 - for low or 1 - for high
      let pr=displayFilterParamsrect.getCurrentValue(1);//percent in the range 0-30
      let np=displayFilterParamsrect.getCurrentValue(0);//even number in the range 2-20

      let isignf=[]; //filtered signal
      let ab = chebyshev1IIR(fc,lh,pr,np);
      let a=ab.a;
      let b=ab.b;

  if (printcoeff){
    console.log('parametrii filtrului: fc=',fc,'lh=',lh,'pr=',pr,'np=',np);
    console.log('ab.a=',a,'ab.b=',b);
  printcoeff=0;
  }
      let num_coeff = np;

      isignf[0]=a[0]*isign[0];
      for (let k=1; k<num_coeff; k++){
        let s=a[0]*isign[k];
        for (let l=1;l<k+1; l++){
          s=s+a[l]*isign[k-l]-b[l]*isignf[k-l];
        };
        isignf[k]=s;
      }
      for (let k=num_coeff; k<buflen; k++){
        let s=a[0]*isign[k];
        for (let l=1;l<num_coeff+1; l++){
          s=s+a[l]*isign[k-l]-b[l]*isignf[k-l];
        };
        isignf[k]=s;
      }
      return isignf;
    }


    function genNoise(a,f1,f2){//512 points, 256 harmonix
      let re=[];
      let im=[];
      let x=[];
//let a=10*a1;
      for (let i=Math.ceil(buflen*f1); i<=Math.floor(buflen*f2); i++){//fill noise spectrum
        re[i]=2*a*(Math.random()-0.5);
        im[i]=2*a*(Math.random()-0.5);
      }

      for (let k=0; k<buflen; k++){//calculate noise signal
        x[k]=0;
        for (let n=Math.ceil(buflen*f1); n<=Math.floor(buflen*f2); n++){
          x[k]=x[k]+2*(re[n]*Math.cos(2*Math.PI*n*k/buflen)-im[n]*Math.sin(2*Math.PI*n*k/buflen));
        }
      }
      return x;
    }

    let visibleVertCubesMenu = undefined;//the shown vertCubesMenu
    let selectedObject = undefined;//the object that invoked the current vertCubesMenu

    class tvertCubesMenu {

      constructor(x,cyup,cydn,z,bgcolor,fgcolor,bgcolor1,texts,camera){
        this.limits=null;
        this.limitsFunc=undefined;
        this.texts=texts;
        this.bgcolor=bgcolor;
        this.fgcolor=fgcolor;
        this.bgcolor1=bgcolor1;
        this.canvas = [];
        this.ctx = [];
        this.textures = [];
        this.materials = [];
        this.cubes = [];
        this.x=0;
        this.y=0;
        this.z=0;
        this.dy=0;
        this.previousSelectedCubeIndex=undefined;

        this.tblrmaterial = new THREE.MeshPhongMaterial({ color: 0x440044 }); // top,bottom,left,right
        let hh=(cyup-cydn)/this.texts.length;
        let h=hh;
        if (h>1) h=1;
        for (let i=0; i<this.texts.length; i++)   {//create all textures
          this.canvas[i] = document.createElement('canvas'); //create a canvas
          this.ctx[i] = this.canvas[i].getContext('2d'); //create a canvas context
          this.canvas[i].width = 256;   //canvas width
          this.canvas[i].height = 256;  //canvas height
          this.drawCanvas(i,0);
          this.textures[i] = new THREE.CanvasTexture(this.canvas[i]);
          this.geometry = new THREE.BoxGeometry(1, h, h);//boxwidth,boxheight, boxdeepth
          this.materials[i] = new THREE.MeshPhongMaterial({map: this.textures[i]}); //make a material of the given texture
          this.cubes[i] = new THREE.Mesh(this.geometry, [
            this.materials[i],//Front texture
            this.tblrmaterial, // top
            this.tblrmaterial, // bottom
            this.tblrmaterial,//left texture
            this.materials[i],//front texture //back texture
            this.tblrmaterial,//right texture
          ]); //make a mesh (here - a cube) from the given materials and geometry

          this.cubes[i].position.x=x;
          this.cubes[i].position.y=cydn+h/2+i*hh;
          this.cubes[i].position.z=z;

          this.cubes[i].userData={
            mod  : 0,
            func : (mod)=>{this.drawCanvas(i,mod); this.cubes[i].userData.mod=mod; this.textures[i].needsUpdate=true;},

            pointerDown : (uv)=>{
              if (this.previousSelectedCubeIndex!==undefined) this.cubes[this.previousSelectedCubeIndex].userData.unselectTexture();//if (this.previousSelectedCube) this.previousSelectedCube.userData.unselectTexture();
              if (i != this.previousSelectedCubeIndex ) {//if (this.cubes[i] != this.previousSelectedCube ) {
                this.cubes[i].userData.selectTexture();
                adjustParameterValueRect.drawParameter(i,this);
                this.previousSelectedCubeIndex = i;//this.previousSelectedCube = this.cubes[i];
              } else {
                this.previousSelectedCubeIndex = undefined;//this.previousSelectedCube = null;
                adjustParameterValueRect.clear();
              }
            },
            selectTexture   : ()=>{this.drawCanvas(i,1); this.textures[i].needsUpdate=true},
            unselectTexture : ()=>{this.drawCanvas(i,0); this.textures[i].needsUpdate=true},
          };

          camera.add(this.cubes[i]);
        }
        this.x=this.cubes[this.texts.length-1].position.x;
        this.z=this.cubes[this.texts.length-1].position.z;
        this.y=this.cubes[this.texts.length-1].position.y;
        this.dy=hh;

        this.hide();//hide the menu
      }

      setParamLimits(limits,limitsFunc){
        this.limits=limits; //[vmin,v,vmax,dv,units],...,[vmin,v,vmax,dv,units]
        this.limitsFunc=limitsFunc;
      }

      hide(){
        this.cubes.forEach((cube, ndx) => {
          cube.visible = false;
          cube.scale.set(0.5,0.5,0.5);
        });
      }

      show(){
        this.cubes.forEach((cube, ndx) => {
          cube.scale.set(1,1,1);
          cube.visible = true;
        });
      }

      drawCanvas(i,mode){//mode=0 uses bgcolor and mode !=0 uses bgcolor1
        let canvas=this.canvas[i];
        let ctx=this.ctx[i];
        let strings=this.texts[i];
        ctx.beginPath();
        ctx.strokeStyle = this.fgcolor;//'gold';
        if (mode==0){
          ctx.fillStyle = this.bgcolor;//'#004444'; //'#333333'; //fill color
        } else {
          ctx.fillStyle = this.bgcolor1;//'#004444'; //'#333333'; //fill color
        }

        ctx.fillRect(1, 1, canvas.width-2*1, canvas.height-2*1); //fill rectangle
        ctx.strokeRect(8, 8, canvas.width-2*8, canvas.height-2*8);
        ctx.font = "40px Times";
        ctx.fillStyle = this.fgcolor;//'#888844'; //fill color '#333333'
        ctx.textAlign = "center";

        let n;
        if (strings.length%2==0) n=strings.length/2; else n=(strings.length-1)/2;
        if (strings.length%2==0) {
          for (let i=0; i<strings.length; i++)
          ctx.fillText(strings[i], canvas.width/2, canvas.height/2+25+(i-n)*50);
        }
        else {
          for (let i=0; i<strings.length; i++)
          ctx.fillText(strings[i], canvas.width/2, canvas.height/2+10+(i-n)*50);
        }
        ctx.arc(canvas.width/2, canvas.height/2, 120, 0, 2 * Math.PI); //x,y,radius, startAngle, endAngle
        ctx.stroke();
      }
    }

    //x,cyup,cydn,z,bgcolor,fgcolor,texts,camera
    const vertCubesMenu =  new tvertCubesMenu(-3.6,2+0.05,-2+0.05,-7,'#004444','gold','#444400',[['Signal','frequency,','%Fs'],['Noise','harmonics,','%A'],  ['Noise band,','%Fs'       ],['Noise','type' ]],camera);
    const vertCubesMenu1 = new tvertCubesMenu(-3.6,2+0.05,-2+0.05,-7,'#004444','gold','#444400',[['Number','of poles'        ],['Passband','ripple,','%A'],['Filter','passband,','%Fs'],['Filter','type']],camera);
    //lim[0]=vmin; lim[1]=vcurrent; lim[2]=vmax; lim[3]=step-any number with two digits max
    //lim[4]=how to mark:
    //0 - mark one value; //1 - mark left range; //2 - mark right range;
    //3 - mark last two values range, the second value should be provided in lim[5]
    //if strings are attached from lim[5] and further - lim[5+k] corresponds to the valuelim[0]+k*lim[3]
    vertCubesMenu.setParamLimits( [[0, 5, 50, 0.1, 0],[0, 300, 300,   1, 0],[0, 35, 50, 0.1, 2],[0, 1, 1, 1, 0,'Low-fr','High-fr']],limitsFunc1);
    vertCubesMenu1.setParamLimits([[2, 2, 20,   2, 0],[0, 0.5, 30,  0.1, 0],[0, 5,  50, 0.1, 1],[0, 0, 1, 1, 0,'L-pass','H-pass' ]],limitsFunc2);

    function limitsFunc1(){
      if (vertCubesMenu.limits[3][1]==0) {vertCubesMenu.limits[2][4]=1}
      else if (vertCubesMenu.limits[3][1]==1) {vertCubesMenu.limits[2][4]=2}
    }

    function limitsFunc2(){
      if (vertCubesMenu1.limits[3][1]==0) {vertCubesMenu1.limits[2][4]=1}
      else if (vertCubesMenu1.limits[3][1]==1) {vertCubesMenu1.limits[2][4]=2}
    }
    //lim[3]: 0,1,2 - 0,1,2 decimals; when=0 strings may be attached
    //lim[3]: -2 - even numbers only;

    //vertCubesMenu.setParamLimits( [[0, 5, 50, 1, 0],[0, 300, 300, 0, 1],[0, 35, 50, 1, 2],[0, 1, 1, 0, 2,'Low-fr','High-fr']]);
    //vertCubesMenu1.setParamLimits([[2, 2, 20,-2, 0],[0, 0.5, 30,  1, 1],[0, 5,  50, 1, 1],[0, 0, 1, 0, 1,'L-pass','H-pass']]);


    const sin2pii_buflen=[];
    const cos2pii_buflen=[];
    for (let i = 0; i < buflen; i++) {
      sin2pii_buflen[i] = Math.sin(2*Math.PI*i/buflen);
      cos2pii_buflen[i] = Math.cos(2*Math.PI*i/buflen);
    }

    //build a geometry
    const boxWidth = 2.5;
    const boxHeight = 1;
    const boxDepth = 2.5;

    //Hadamard matrices
  /*
    0,1,2,3,4,5,6,7,8,9,10
    1,3,5,7,9,0,2,4,6,8,
    0,3,4,8,2,
    1,7,9,6,5,10

    0,1,2,3,4,5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18
    1,3,5,7,9,11,13,15,17,0,2, 4, 6, 8, 10,12,14,16
    0,3,15,6, 8, 16,10,5, 4,
    1,7,12,13,17,14, 2,11,9,18

  0,1,2,3,4,5, 6, 7, 8, 9, 10,11,12,13,14,15,16,17,18,19,20,21,22
  1,3,5,7,9,11,13,15,17,19,21,0, 2, 4, 6, 8, 10,12,14,16,18,20
  0,3,15,17,2,11, 4,19,10,20,14,13,
  1,7,8, 12,5,    9,16,21,18,6,22
  */

    let d=23;
    const Had2=[];
    const Hadp=[];
    const Hadm=[];
    console.log('--Dimension=',d);
    for (let i = 0; i < d; i++) {
      Had2[i]=(2*i+1)%d;
    }
    let ind2=0;
    Hadp.push(ind2);
    let p0m1=1;
    let val1=0;
    let ind=0;

    ind2=Had2[ind2];//first value from Had2

    do {
      do {
        if (p0m1==1) {
          Hadm.push(ind2);
          console.log('push to Hadm=',ind2,' p0m1=',p0m1);
          p0m1=0;
        }
        else {
          Hadp.push(ind2);
          console.log('push to Hadp=',ind2,' p0m1=',p0m1);
          p0m1=1;
        }
        ind2=Had2[ind2];
        console.log('do while ',ind2,' != ',val1);
      } while (ind2 != val1);

      // console.log('for cycle');

      for (let ind1=1; ind1<d; ind1++) {
        ind2=Had2[ind1];
        if (!(Hadp.includes(ind2) || Hadm.includes(ind2))) {
          val1=ind2;
          ind=ind1;
          console.log('element ',ind2,' is not included in Hadp or Hadm');
          break;
        } else {
          console.log('element ',ind2,' is included in Hadp or Hadm');
        }
      }

      console.log(' outer do while cycle, ind=',ind,' d-1=',d-1);
    } while (ind != (d-1));

    if (p0m1==1) {
      Hadm.push(ind2);
      console.log('push to Hadm=',ind2,' p0m1=',p0m1);
      p0m1=0;
    }
    else {
      Hadp.push(ind2);
      console.log('push to Hadp=',ind2,' p0m1=',p0m1);
      p0m1=1;
    }

    console.log('Hadp=',Hadp);
    console.log('Hadm=',Hadm);

    let Had1=[];
    Had1.length = d;

    if (Hadp.length < Hadm.length) {
      for (let i=0; i<Hadp.length; i++) {
        ind=Hadp[i];
        Had1[ind]=1;
      }
      for (let i=0; i<Hadm.length; i++) {
        ind=Hadm[i];
        Had1[ind]=-1;
      }
    } else {
      for (let i=0; i<Hadp.length; i++) {
        ind=Hadp[i];
        Had1[ind]=-1;
      }
      for (let i=0; i<Hadm.length; i++) {
        ind=Hadm[i];
        Had1[ind]=1;
      }
    }

    console.log('Had1=',Had1);

    for (let i=1; i<Had1.length; i++) {
      let s=0;
      for (let j=0; i<Had1.length; i++) {
        s=s+Had1[j]*Had1[(j+i)%d];
      }
      console.log('s[',i,']=',s);
    }



    /*
    cubes.forEach((cube, ndx) => {
      const speed = 0.2 + ndx * .00125;
      const rot = time * speed;
      cube.rotation.x = rot;
      cube.rotation.y = rot;
    });
    */
    //Hadamard matrices


    class tdisplaySpectrumRect {

      constructor (w,h,d,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,camera) {
        this.fgcolor=fgcolor;
        this.bgcolor=bgcolor;
        this.canvas = document.createElement('canvas'); //create a canvas
        let canvas=this.canvas;
        this.texture = new THREE.CanvasTexture(canvas);//create a texture based on this canvas;
        canvas.width = canvas_width;   //canvas width
        canvas.height = canvas_height;  //canvas height
        this.ctx = canvas.getContext('2d'); //create a canvas context
        let ctx=this.ctx;
/*
        ctx.font = "40px Times";
        ctx.strokeStyle = this.fgcolor;
        ctx.fillStyle = this.fgcolor;
        ctx.textAlign = "left";
        ctx.fillText("Signal frequency:", 20, this.canvas.height-25);
        ctx.fillText("Noise level:     ", 20, this.canvas.height-65);
*/
        ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
        ctx.strokeRect(0, 12, this.canvas.width-2*6, this.canvas.height-2*12);
        //ctx.beginPath();
        //ctx.moveTo(this.canvas.width/2-4,7);
        //ctx.lineTo(this.canvas.width/2-4,this.canvas.height-8);
        //ctx.stroke();
        ctx.fillStyle = this.bgcolor;
        this.drawSpectrum();
/*
        let material = new THREE.MeshPhongMaterial({map: this.texture}); //make a material of the given texture
        let material0 = new THREE.MeshPhongMaterial({ color: this.bgcolor }); // material with the given color
        let geometry = new THREE.BoxGeometry(w, h, d);
        this.cube = new THREE.Mesh(geometry, [
          material,//Front texture
          material,//back texture
          material0,//top material
          material0,// bottom
          material,//left texture
          material,//right texture
        ]); //make a mesh (here - a cube) from the given materials and geometry
        scene.add(this.cube);

        this.cube.position.x = x;
        this.cube.position.y = y;
        this.cube.position.z = z;
*/
        let geometry1 = new THREE.PlaneGeometry( w, h );
        let material1 = new THREE.MeshPhongMaterial( {map:this.texture} );
        let plane = new THREE.Mesh( geometry1, material1 );
        camera.add( plane );
        plane.position.x=x;
        plane.position.y=y;
        plane.position.z=z;
      }

      drawSpectrum () {
        let ctx=this.ctx;
        let w = this.canvas.width;

        //ctx.beginPath();
        ctx.clearRect(0, 0, w, canvas_height);
        ctx.fillStyle = this.bgcolor;
        ctx.strokeStyle = this.fgcolor;
        ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
        ctx.fillRect(8+1, ym-signal_ampl, w-2*8-2, 2*signal_ampl); //fill rectangle

        for (let n = 0; n < buflen/2+1; n++) { //calculate signal harmonics (first part)
          x[n]=0;
          y[n]=0;
          for (let i = 0; i < buflen; i++) {
            x[n] = x[n] + isign[i]*cos2pii_buflen[(i*n) % buflen];
            y[n] = y[n] + isign[i]*sin2pii_buflen[(i*n) % buflen];
          }
          sp[n]=Math.sqrt(x[n]**2+y[n]**2)*2/buflen;
        }
        for (let n = buflen/2+1; n < buflen; n++) {//signal harmonics (second part)
          x[n]=x[buflen-n];
          y[n]=-y[buflen-n];
          sp[n]=Math.sqrt(x[n]**2+y[n]**2)*2/buflen;//calculate AF spectrum
        }

        ctx.beginPath();
        ctx.moveTo(12,ym); //draw signal with noise spectrum
        ctx.lineTo(buflen,ym);
        for (let i = 0; i < buflen; i++) {
          ctx.moveTo(11+i,ym);
          ctx.lineTo(11+i,ym-sp[i]);
        }
        ctx.stroke();
        this.texture.needsUpdate=true;
      }
    }

    class tdisplaySignalRect {
      constructor(w,h,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,camera) {
        this.fgcolor=fgcolor;
        this.bgcolor=bgcolor;

        this.canvas = document.createElement('canvas'); //create a canvas
        let canvas=this.canvas;
        this.texture = new THREE.CanvasTexture(canvas);//create a texture based on this canvas;
        canvas.width = canvas_width;   //canvas width
        canvas.height = canvas_height;  //canvas height
        this.ctx = canvas.getContext('2d'); //create a canvas context
        let ctx=this.ctx;
        ctx.strokeStyle = this.fgcolor;
        ctx.fillStyle = this.bgcolor;

        let geometry1 = new THREE.PlaneGeometry( w, h );
        let material1 = new THREE.MeshPhongMaterial( {map:this.texture} );
        let plane = new THREE.Mesh( geometry1, material1 );
        camera.add( plane );
        plane.position.x=x;
        plane.position.y=y;
        plane.position.z=z;
      }

      drawSignal() {

        let ctx = this.ctx;
        let w = this.canvas.width;
        let h = this.canvas.height;
        let ym1 = h/2;
        ctx.clearRect(0, 0, w, h);
        ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
        ctx.fillRect(8+1, ym1-signal_ampl, w-2*8-2, 2*signal_ampl); //fill rectangle

        ctx.beginPath();
        ctx.moveTo(12,ym1);

        let noiseCutoffFr=displaySignalParamsrect.getCurrentValue(2)/100;//noise cutoff frequency as a fraction of sampling rate
        let noiseAmp=displaySignalParamsrect.getCurrentValue(1)/100;
        if ( displaySignalParamsrect.getCurrentValue(3) == 0 ){//noise type == Low_fr
          let x=genNoise(15,0,noiseCutoffFr);
          for (let i = 0; i < buflen; i++) {
            isign[i]=isin[i] + x[i]*noiseAmp;
            ctx.lineTo((i+10),ym1 - isign[i]); //draw the signal with noise
          }
        } else {
          let x=genNoise(15,noiseCutoffFr,0.5);
          for (let i = 0; i < buflen; i++) {
            isign[i]=isin[i] + x[i]*noiseAmp;
            ctx.lineTo((i+10),ym1 - isign[i]); //draw the signal with noise
          }
        }

        ctx.stroke();
        this.texture.needsUpdate=true;
      }

      drawIsign() {
        let ctx = this.ctx;
        let w = this.canvas.width;
        let h = this.canvas.height;
        let ym1 = h/2;
        ctx.clearRect(0, 0, w, h);
        ctx.strokeRect(8, 8, w-2*8, h-2*8);
        ctx.fillRect(8+1, ym1-signal_ampl, w-2*8-2, 2*signal_ampl); //fill rectangle

        ctx.beginPath();
        ctx.moveTo(12,ym1);
        for (let i = 0; i < buflen; i++) {
          //isign[i]=isin[i] + Math.floor((0.5-Math.random()) * 2*noise_ampl);//add noise th the signal
          ctx.lineTo((i+10),ym1 - isign[i]); //draw the signal with noise
        }
        ctx.stroke();
        this.texture.needsUpdate=true;
      }

      drawFilteredIsign() {
        let ctx = this.ctx;
        let w = this.canvas.width;
        let h = this.canvas.height;
        let ym1 = h/2;
        ctx.clearRect(0, 0, w, h);
        ctx.strokeRect(8, 8, w-2*8, h-2*8);
        ctx.fillRect(8+1, ym1-signal_ampl, w-2*8-2, 2*signal_ampl); //fill rectangle

        ctx.beginPath();
        ctx.moveTo(12,ym1);

        let isignf=filterIsignBuf();

        for (let i = 0; i < buflen; i++) {
          //isign[i]=isin[i] + Math.floor((0.5-Math.random()) * 2*noise_ampl);//add noise th the signal
          ctx.lineTo((i+10),ym1 - isignf[i]); //draw the signal with noise
        }
        ctx.stroke();
        this.texture.needsUpdate=true;
      }

      drawbuf(buf) {
        let ctx = this.ctx;
        let w = this.canvas.width;
        let h = this.canvas.height;
        let ym1 = h/2;
        ctx.clearRect(0, 0, w, h);
        ctx.strokeRect(8, 8, w-2*8, h-2*8);
        ctx.fillRect(8+1, ym1-signal_ampl, w-2*8-2, 2*signal_ampl); //fill rectangle

        ctx.beginPath();
        ctx.moveTo(12,ym1);

        for (let i = 0; i < buflen; i++) {
          //isign[i]=isin[i] + Math.floor((0.5-Math.random()) * 2*noise_ampl);//add noise th the signal
          ctx.lineTo((i+10),ym1 - buf[i]); //draw the signal with noise
        }
        ctx.stroke();
        this.texture.needsUpdate=true;
      }
    }


class tdisplaySignalParamsrect {
  constructor (w, h, x, y, z, bgcolor, fgcolor, canvas_width, canvas_height, camera, vertCubesMenu, title) {
    this.title=title;
    this.select=0;
    this.vertCubesMenu=vertCubesMenu;
    this.fgcolor=fgcolor;
    this.bgcolor=bgcolor;
    this.canvas = document.createElement('canvas'); //create a canvas
    let canvas=this.canvas;
    canvas.width = canvas_width;   //canvas width
    canvas.height = canvas_height;  //canvas height
    this.ctx = canvas.getContext('2d'); //create a canvas context
    let ctx=this.ctx;
    this.texture = new THREE.CanvasTexture(canvas);//create a texture based on this canvas;
    this.drawParams(0);//not selected
    let geometry1 = new THREE.PlaneGeometry( w, h );
    let material1 = new THREE.MeshPhongMaterial( {map:this.texture} );
    let plane = new THREE.Mesh( geometry1, material1 );
    camera.add( plane );
    plane.position.x=x;
    plane.position.y=y;
    plane.position.z=z;

    plane.userData={
      pointerDown : (uv)=>{
        if (visibleVertCubesMenu == undefined) { //if vert menus are not dispayed
          this.vertCubesMenu.show(); //show the menu for the selected object
          visibleVertCubesMenu = this.vertCubesMenu;
            //
          if (this.vertCubesMenu.previousSelectedCubeIndex !== undefined) adjustParameterValueRect.drawParameter(this.vertCubesMenu.previousSelectedCubeIndex,this.vertCubesMenu);
          this.drawParams(1);//selected

          selectedObject=this;
        } else if (this.vertCubesMenu !== visibleVertCubesMenu) {//if vert menu was dispayed and the new vert menu differes from it
          visibleVertCubesMenu.hide();
          selectedObject.drawParams(0);
  adjustParameterValueRect.clear();
          this.vertCubesMenu.show(); //show the menu for the selected object

          if (this.vertCubesMenu.previousSelectedCubeIndex !== undefined) adjustParameterValueRect.drawParameter(this.vertCubesMenu.previousSelectedCubeIndex,this.vertCubesMenu);
          this.drawParams(1);//selected

          selectedObject=this;
          visibleVertCubesMenu = this.vertCubesMenu;
        } else {//click on the same menu
          visibleVertCubesMenu.hide();
          visibleVertCubesMenu = undefined;
          selectedObject.drawParams(0);
          selectedObject=undefined;
    adjustParameterValueRect.clear();
        }

      }
    }
  }

  getCurrentValue(i){//returns the current value of i parameter
    return(this.vertCubesMenu.limits[i][1]);
  }

  drawParams(select){
    this.select=select;
    let ctx = this.ctx;
    if (select==1) {ctx.fillStyle = '#444400'} else {ctx.fillStyle = this.bgcolor};
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = "40px Times";
    ctx.strokeStyle = this.fgcolor;
    ctx.fillStyle = this.fgcolor;

    ctx.textAlign = "center";
    ctx.fillText(this.title, this.canvas.width/2, 40);

    let texts=this.vertCubesMenu.texts;
    for (let i=0; i<texts.length; i++){
      let strings = texts[i];
      let s='';
      strings.forEach((string, ndx) => {
        s=s+' '+string;
      });
      ctx.textAlign = "left";
      ctx.fillText(s+':', 4, this.canvas.height-25-i*40);
      ctx.textAlign = "right";
      let lim=this.vertCubesMenu.limits[i];

      let c=0;
      if ((lim[3]*100)%10!==0) {c=2}
      else if ((lim[3]*10)%10!==0) {c=1};
      let n=0;

      switch(lim[4]) {
        case 0:
          if (lim[5]!==undefined){
            n=Math.round((lim[1]-lim[0])/lim[3]);
            s=lim[5+n];
          } else s=lim[1].toFixed(c);
          break;
        case 1:
          s=lim[0].toFixed(c)+'-'+lim[1].toFixed(c);
          // code block
          break;
        case 2:
          s=lim[1].toFixed(c)+'-'+lim[2].toFixed(c);
          break;
        case 3:
          s=lim[1].v1.toFixed(c)+'-'+lim[1].v2.toFixed(c);
          break;
        default:
          // code block
      }
      ctx.fillText(s, this.canvas.width-10, this.canvas.height-25-i*40);
    }
    ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
    this.texture.needsUpdate=true;
  }

  drawParamsInCurrentState(){//draw params without changing the state of the window
    let ctx = this.ctx;
    if (this.select==1) {ctx.fillStyle = '#444400'} else {ctx.fillStyle = this.bgcolor};
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = "40px Times";
    ctx.strokeStyle = this.fgcolor;
    ctx.fillStyle = this.fgcolor;

    ctx.textAlign = "center";
    ctx.fillText(this.title, this.canvas.width/2, 40);

    let texts=this.vertCubesMenu.texts;
    for (let i=0; i<texts.length; i++){
      let strings = texts[i];
      let s='';
      strings.forEach((string, ndx) => {
        s=s+' '+string;
      });
      ctx.textAlign = "left";
      ctx.fillText(s+':', 4, this.canvas.height-25-i*40);
      ctx.textAlign = "right";
      let lim=this.vertCubesMenu.limits[i];

      let c=0;
      if ((lim[3]*100)%10!==0) {c=2}
      else if ((lim[3]*10)%10!==0) {c=1};
      let n=0;

      switch(lim[4]) {
        case 0:
          if (lim[5]!==undefined){
            n=Math.round((lim[1]-lim[0])/lim[3]);
            s=lim[5+n];
          } else s=lim[1].toFixed(c);
          break;
        case 1:
          s=lim[0].toFixed(c)+'-'+lim[1].toFixed(c);
          // code block
          break;
        case 2:
          s=lim[1].toFixed(c)+'-'+lim[2].toFixed(c);
          break;
        case 3:
          s=lim[1].v1.toFixed(c)+'-'+lim[1].v2.toFixed(c);
          break;
        default:
          // code block
      }
      ctx.fillText(s, this.canvas.width-10, this.canvas.height-25-i*40);
    }
    ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
    this.texture.needsUpdate=true;
  }
}

    class tadjustParameterValueRect {
      constructor(w,h,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,camera) {
        this.vertCubesMenu=undefined;
        this.cubeindex=undefined;
        this.fgcolor=fgcolor;
        this.bgcolor=bgcolor;
        this.fgcolor1='#666600';
        this.canvas = document.createElement('canvas'); //create a canvas
        let canvas=this.canvas;
        canvas.width = canvas_width*2;
        canvas.height = canvas_height;  //canvas height
        this.ctx = canvas.getContext('2d'); //create a canvas context
        let ctx=this.ctx;
        this.texture = new THREE.CanvasTexture(canvas);//create a texture based on this canvas;

        ctx.fillStyle = this.bgcolor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = this.fgcolor;
        ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);

        ctx.font = "40px Times";

        let geometry1 = new THREE.PlaneGeometry( w, h );
        this.boxwidth=w;
        let material1 = new THREE.MeshPhongMaterial( {map:this.texture} );
        let plane = new THREE.Mesh( geometry1, material1 );
        camera.add( plane );
        plane.position.x=x;
        plane.position.y=y;
        plane.position.z=z;
        this.plane=plane;
        this.cubeindex=undefined;

        plane.userData={
          pointerDown : (uv)=>{
          if (this.cubeindex !== undefined) {
            let lim=this.vertCubesMenu.limits[this.cubeindex];
            let x=lim[0]+(lim[2]-lim[0])*uv.x;//x=new raw current value

            let n=Math.floor(x/lim[3]);//n=how many steps are in current value;

            if (lim[4]!==3) {//if it isn't a double sided range
              if (x<lim[1]) {lim[1]=n*lim[3]} else {lim[1]=(n+1)*lim[3]}
            }
            else {//double sided range
              let val1=lim[1].v1;
              let val2=lim[1].v2;
              if (x < val2) {
                if (x<val1) {lim[1]={v1:n*lim[3], v2:val2} } else {lim[1]={v1:(n+1)*lim[3],v2:val2}};
              }
              else {
                if (x<val2) {lim[1]={v1:val1,v2:n*lim[3]}} else {lim[1]={v1:val1,v2:(n+1)*lim[3]}};
              }
            }

            this.vertCubesMenu.limits[this.cubeindex]=lim;

            if (selectedObject==displaySignalParamsrect)
            switch(this.cubeindex) {
              case 0:
                f=fd*lim[1]/100;
                //console.log('f=',f);
                for (let i = 0; i < buflen; i++) isin[i] = signal_ampl*Math.cos(2*Math.PI*i*f/fd);
                break;
              case 1:
                noise_ampl=signal_ampl*lim[1]/100;
                // code block
                break;
              default:
                // code block
            }
/*
            else if (selectedObject==displayFilterParamsrect)
    printcoeff=0;//use 1 to print filter coeff with console.log()
            switch(this.cubeindex) {
              case 0:
                console.log('case 0');
                break;
              case 1:
                console.log('case 1');
                // code block
                break;
              case 2:
                console.log('case 2');
                break;
              case 3:
                console.log('case 3');
                break;
              default:
                // code block
            }
*/
            this.drawParameter(this.cubeindex,this.vertCubesMenu);
            } else console.log('parameter not selected!!!');
          }
        }

      }

      drawParameter(i,vertCubesMenu){
        this.cubeindex=i;//selected parameter has index i

        this.vertCubesMenu=vertCubesMenu;
        let ctx=this.ctx;
        ctx.fillStyle = this.bgcolor;
        ctx.fillRect(8+1, 8+1, this.canvas.width-2*8-2, this.canvas.height-2*8-2);//clear the inside rectangular zone;
        let strings = vertCubesMenu.texts[i];
        let s='';
        strings.forEach((string, ndx) => {
          s=s+' '+string;
        });
        ctx.textAlign = "center";
        ctx.fillStyle = this.fgcolor;
        ctx.fillText(s, this.canvas.width/2, 50); //output parameter name on the rectangle

        let lim=vertCubesMenu.limits[i];//parameter's limits

        ctx.fillStyle = this.fgcolor1;
        ctx.textAlign = "left";
        if (lim[5]==undefined){//if there are no strings
          ctx.fillText(lim[0], 11, 50+40); //output minimal value
          ctx.textAlign = "right";
          ctx.fillText(lim[2], this.canvas.width-11, 50+40);//output maximal value
        } else {//there are strings
          ctx.fillText(lim[5], 11, 50+40); //output minimal value
          ctx.textAlign = "right";
          ctx.fillText(lim[lim.length-1], this.canvas.width-11, 50+40);//output maximal value
        }
        let x=0;
        let x1=0;
        let x2=0;
        let c=0;
        if ((lim[3]*100)%10!==0) {c=2}
        else if ((lim[3]*10)%10!==0) {c=1};

        switch(lim[4]) {
          case 0://single value
            //console.log('case 0');
            ctx.fillStyle = this.fgcolor;

            let numb=(lim[2]-lim[0])/lim[3];
            let w=(this.canvas.width-20)/(numb+1);
            x=10+((lim[1]-lim[0])/lim[3])*w;
            ctx.fillRect(x, 100, w, this.canvas.height-2*8-50-100);

            ctx.beginPath();
            ctx.moveTo(x+w/2,100);
            ctx.lineTo(x+w/2,200);
            ctx.stroke();
            if ( x < this.canvas.width/2 ) {ctx.textAlign = "left"}
            else ctx.textAlign = "right";

            if (lim[5]==undefined){//if there are no strings
              ctx.fillText(lim[1].toFixed(c), x+w/2, this.canvas.height-20);
            } else {
              ctx.fillText(lim[5+Math.floor(lim[1]/lim[3])], x+w/2, this.canvas.height-20);
            }
            break;
          case 1://left range
            //console.log('case 1');
            ctx.fillStyle = this.fgcolor;
            x=(this.canvas.width-20)*(lim[1]-lim[0])/(lim[2]-lim[0]);
            x=Math.round(x);
            ctx.fillRect(10, 100, x, this.canvas.height-2*8-50-100);

            if ( x < this.canvas.width/2 ) {ctx.textAlign = "left"}
            else ctx.textAlign = "right";

            if (lim[5]==undefined){//if there are no strings
              ctx.fillText(lim[1].toFixed(c), x+8, this.canvas.height-20);
            } else {
              ctx.fillText(lim[1], x+8, this.canvas.height-20);
            }
            // code block
            break;
          case 2://right range
            //console.log('case 2');
            ctx.fillStyle = this.fgcolor;
            x=(this.canvas.width-20)*(lim[1]-lim[0])/(lim[2]-lim[0]);
            x=Math.round(x);
            ctx.fillRect(10+x, 100, this.canvas.width-x-20, this.canvas.height-2*8-50-100);

            if ( x < this.canvas.width/2 ) {ctx.textAlign = "left"}
            else ctx.textAlign = "right";

            if (lim[5]==undefined){//if there are no strings
              ctx.fillText(lim[1].toFixed(c), x+8, this.canvas.height-20);
            } else {
              ctx.fillText(lim[1], x+8, this.canvas.height-20);
            }
            break;
          case 3://double sided range
            //console.log('case 3');
            ctx.fillStyle = this.fgcolor;
            x1=(this.canvas.width-2*8-4)*(lim[1].v1-lim[0])/(lim[2]-lim[0]);
            x2=(this.canvas.width-2*8-4)*(lim[1].v2-lim[0])/(lim[2]-lim[0]);
            x1=Math.round(x1);
            x2=Math.round(x2);
            ctx.fillRect(10+x1, 100, 10+x2, this.canvas.height-2*8-50-100);
            if ( x1 < this.canvas.width/2 ) {ctx.textAlign = "left"}
            else ctx.textAlign = "right";

            if (lim[5]==undefined){//if there are no strings
              s=lim[1].v1.toFixed(c)+'-'+lim[1].v2.toFixed(c);
            } else {
              s=lim[1].v1.toFixed(c)+'-'+lim[1].v2.toFixed(c);
            }
            ctx.fillText(s, x1+8, this.canvas.height-20);
            break;
          default:
            // code block
        }
        this.texture.needsUpdate=true;
        if (vertCubesMenu.limitsFunc!==undefined) vertCubesMenu.limitsFunc();
        if (selectedObject!==undefined) selectedObject.drawParamsInCurrentState();
      }

      clear(){
        this.cubeindex=undefined; //parameter not selected
        let ctx=this.ctx;
        ctx.fillStyle = this.bgcolor;
        ctx.fillRect(8+1, 8+1, this.canvas.width-2*8-2, this.canvas.height-2*8-2);
        this.texture.needsUpdate=true;
      }
    }

    // window to change the curren parameter's value  //w,h,d,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,string,vmin,v,vmax,units,scene
    const adjustParameterValueRect = new tadjustParameterValueRect(boxWidth*2, boxHeight, vertCubesMenu.x+vertCubesMenu.dy + 3*boxWidth/2, vertCubesMenu.y-6*vertCubesMenu.dy/2, vertCubesMenu.z,'#004444','gold',canvas_width,canvas_height,camera);
    //initial signal parameters and their values
    const displaySignalParamsrect = new tdisplaySignalParamsrect(boxWidth,boxHeight,   vertCubesMenu.x+vertCubesMenu.dy+boxWidth, vertCubesMenu.y-0*vertCubesMenu.dy, vertCubesMenu.z,'#440044','gold',canvas_width,canvas_height,camera, vertCubesMenu,'Input Signal Params');
    //initial signal parameters and their values
    const displayFilterParamsrect = new tdisplaySignalParamsrect(boxWidth,boxHeight,   vertCubesMenu.x+vertCubesMenu.dy+2*boxWidth, vertCubesMenu.y-0*vertCubesMenu.dy, vertCubesMenu.z,'#440044','gold',canvas_width,canvas_height,camera, vertCubesMenu1,'IIR Chebyshev Filter Params');
    // initial signal
    const displaySignalRect =         new tdisplaySignalRect(boxWidth, boxHeight, vertCubesMenu.x+vertCubesMenu.dy+boxWidth, vertCubesMenu.y-vertCubesMenu.dy, vertCubesMenu.z,'#440044','gold',canvas_width,canvas_height,camera);
    // signal after filtering
    const displayFilteredSignalRect = new tdisplaySignalRect(boxWidth, boxHeight, vertCubesMenu.x+vertCubesMenu.dy+2*boxWidth, vertCubesMenu.y-vertCubesMenu.dy, vertCubesMenu.z,'#440044','gold',canvas_width,canvas_height,camera);
    // filter characteristic
    const displayFilterCharRect = new tdisplaySignalRect(boxWidth, boxHeight, vertCubesMenu.x+vertCubesMenu.dy+2*boxWidth, vertCubesMenu.y-2*vertCubesMenu.dy, vertCubesMenu.z,'#440044','gold',canvas_width,canvas_height,camera);

    // initial signal spectrum
    const displaySpectrumRect = new tdisplaySpectrumRect(boxWidth, boxHeight, boxDepth, vertCubesMenu.x+vertCubesMenu.dy+boxWidth, vertCubesMenu.y-4*vertCubesMenu.dy/2, vertCubesMenu.z,'#440044','gold',canvas_width,canvas_height,camera);


    class PickHelper {
      constructor() {
        this.raycaster = new THREE.Raycaster();
        this.selectedObject = null; // the former selected object
      }

      pick(normalizedPosition, scene, camera/*, time*/) {
        this.raycaster.setFromCamera(normalizedPosition, camera);  // cast a ray through the frustum
        // get the list of objects the ray intersected
        const intersectedObjects = this.raycaster.intersectObjects(camera.children);
        if (intersectedObjects.length){
          if (intersectedObjects[0].object.visible)   intersectedObjects[0].object.userData.pointerDown(intersectedObjects[0].uv);
        }
      }
    }

    const pickPosition = {x: 0, y: 0};
    const pickHelper = new PickHelper();

    function getCanvasRelativePosition(event) {
      const rect = canvas.getBoundingClientRect();//gets left, top, right, bottom, x, y, width, height of the document canvas
      return {
        x: (event.clientX - rect.left) * canvas.width  / rect.width,
        y: (event.clientY - rect.top ) * canvas.height / rect.height,
      };
    }

    function setPickPosition(event) {
      const pos = getCanvasRelativePosition(event);
      pickPosition.x = (pos.x / canvas.width ) *  2 - 1;
      pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y
      //pickPosition is now in normalized form (between -1 and 1 and the left bottom point is (-1,-1) while the top right point is (1,1))
    }

    window.addEventListener('pointerdown', (event) => {        //'touchmove' event occurs when a finger is dragged across the window
      setPickPosition(event);
      pickHelper.pick(pickPosition, scene, camera/*, time*/);
 //console.log('pointerdown',event.pageX,' ',event.pageY,'pickPosition=',pickPosition);
    });



    //window.addEventListener('mousemove', setPickPosition);   //'mousemove'event occurs when the pointer is moving while it is over the window
    window.addEventListener('touchstart', (event) => {        //'touchmove' event occurs when a finger is dragged across the window
      setPickPosition(event.touches[0]);
      pickHelper.pick(pickPosition, scene, camera/*, time*/);
    });

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      const width = window.innerWidth; //canvas.clientWidth;
      const height = window.innerWidth * 0.5; //canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, true);
      }
      return needResize;
    }

//    controls.addEventListener('change', (event) => {console.log('change'); });
    controls.addEventListener('start', (event) => {
      //console.log("Controls Start Event", event)
    });
//    controls.addEventListener('end', (event) => console.log("Controls End Event"));

    function render(time) { //render function rotates cubes and renderer displays them on screen
      time *= 0.001;  // convert time to seconds

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      displaySignalRect.drawSignal();

      displayFilteredSignalRect.drawFilteredIsign();//.drawIsign();

      displaySpectrumRect.drawSpectrum()

/*
      cubes.forEach((cube, ndx) => {
        const speed = 0.2 + ndx * .00125;
        const rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
      });

      cameraPole.rotation.y = -time * 0.05; //rotate camera
      cubesPole.rotation.y = -time * 0.15; //rotate c3 cubes
*/

      renderer.render(scene, camera); //renderer renders the given scene using given camera
      requestAnimationFrame(render);  //requests a new frame using the render function and exits the function
    }

    requestAnimationFrame(render); //requests the first frame using the render function

  }

  main();

  </script>

<!--
  <h1> <a href="https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html"> https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html </a> threejs fundamentals </h1>
-->
  <canvas id="myCanvas">  </canvas>

</body>


</html>
