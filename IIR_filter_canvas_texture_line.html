<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title> La multi ani! </title>

  <!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->

    <style>
  	  body { margin: 0; }
    </style>
  </head>
  <body>
  <!-- the styles for this page in the local file main.css (in the /static/ directory mandatory!!!)-->
  <!-- <link href="/static/css/main.css" rel="stylesheet" type="text/css"> -->
<!--
  <div>
    <table style="width:100%">
      <tr>
        <th>
          <img id='image01' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-1.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image02' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-2.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image03' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-3.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image04' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-4.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image05' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-5.jpg'  height=128 width=128/>
        </th>
        <th>
          <img id='image06' crossOrigin = "Anonymous" src='https://threejsfundamentals.org/threejs/resources/images/flower-6.jpg'  height=128 width=128/>
        </th>
        <th>
          <video id='video1' crossOrigin = "Anonymous" autoplay muted loop src='https://raw.githubusercontent.com/vasilesirbu1957/newrepo/main/video1.mov' type="video/mp4" width="128" height="128">
        </th>
        <th>
          <video id='video2' crossOrigin = "Anonymous" autoplay muted loop src='./video1.mov' type="video/mp4"  width="128" height="128">
        </th>
      </tr>
    </table>
  </div>
  -->
  <!-- the main.js module of our 3d application for this page -->
  <script type="module" crossOrigin = "Anonymous" >

  import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/build/three.module.js';
  import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r125/examples/jsm/controls/OrbitControls.js';
  import {createSkyboxFlowersScene,
          createHemisphereLight,
          createDirectionalLight,
          createPerspectiveCamera} from 'https://raw.githack.com/vasilesirbu1957/newrepo/main/js/scenes.js';

  function main() {
  //   'use strict';
    const canvas = document.querySelector('#myCanvas');
    const renderer = new THREE.WebGLRenderer({canvas},{ antialias: true });
    renderer.physicallyCorrectLights = true;
    renderer.setSize(window.innerWidth, window.innerWidth * 0.5); //square size width=100%, height=50% of width

  const scene = createSkyboxFlowersScene(); //create a skybox scene
/*
    //camera
    const fov = 35;    // camera field of view in degrees
    const aspect = 2;  // the canvas default aspect ratio = 2
    const near =0.1;  // the camera near distance (frustrum start)
    const far = 60;    // the camera far distance (frustrum end)
*/
    const camera = createPerspectiveCamera({fov:35, aspect:2, near:0.1, far:60, x:0, y:0, z:9}, scene);

    // put the camera on a pole (parent it to an object)
    // so we can spin the pole to move the camera around the scene
    /*
    const cameraPole = new THREE.Object3D();
    scene.add(cameraPole);
    cameraPole.add(camera);
    */

    // orbit controls  - rotate and zoom in/out
    const controls = new OrbitControls(camera, canvas);
    controls.target.set(0, 0, 0); //move the scene up (to -0.5 on Y coord)
    controls.update();
       //limit zoom in and out when using THREE.OrbitControls with perspective camera:
    controls.minDistance = 5.0;
    controls.maxDistance = 60.0;
    //limit zoom in and out when using THREE.OrbitControls with ortographic camera:
    //controls.minZoom = 2.0;
    //controls.maxZoom = 40.0;


    //hemisphere light to have light from everywhere
    const Hlight = createHemisphereLight({skyColor:0xFFFFFF, groundColor:0xB97A20, intensity:3}, scene);

    //directional light to have light from the given direction
    const Dlight = createDirectionalLight({color:0xFFFFFF, intensity:3, x:0, y:0, z:5}, camera);

function getpolepair(fc,lh,pr,np,p){
  //fc the cutoff frequency in range 0 - 0.5 of sampling frequency; for a cutoff frequency of 0.1*sf  just enter fc=0.1
  //lh indicates the filter type: lh=0 low pass filter, lh=1 - high pass filter
  //pr indicates the percent ripple in range 0-29 that corresponds to 9-29% ripple in the passband
  //np the number of poles (even number from 2 to 20)
  //p is the poles pair number from 0 to np/2
console.log('inside getpolepair');
  let c={a0:0,a1:0,a2:0,b1:0,b2:0};// the the coefficients for the current poles pair will be kept here
  let rp,ip;//real and imaginary parts of poles
  let es,vx,kx,t,w,m,d,k;
  let x0,x1,x2,y1,y2;
  //calculate the pole pair location on the unit circle
  rp=-Math.cos(Math.PI/(2*np)+(p-1)*Math.PI/np);//the pole real part on the unit circle
  ip= Math.sin(Math.PI/(2*np)+(p-1)*Math.PI/np);//the pole imaginary part

  if (pr>0){//if ripple is allowed then warp from the unit circle to an ellipse
    es=Math.sqrt((100/(100-pr))**2-1);
    vx=(1/np)*Math.log((1/es)+Math.sqrt((1/es)**2+1));
    kx=(1/np)*Math.log((1/es)+Math.sqrt((1/es)**2-1));
    kx=(Math.exp(kx)+Math.exp(-kx))/2;
    rp=rp*((Math.exp(vx)-Math.exp(-vx))/2)/kx;
    ip=ip*((Math.exp(vx)+Math.exp(-vx))/2)/kx;
  }
console.log('----rp=',rp,'ip=',ip);
  //s-domain to z-domain conversion
  t=2*Math.tan(0.5);
  w=2*Math.PI*fc;
  m=rp**2+ip**2;//(pole module)**2;
  d=4-4*rp*t+m*t**2;
  x0=(t**2)/d;
  x1=2*(t**2)/d;
  x2=(t**2)/d;
  y1=(8-2*m*t**2)/d;
  y2=(-4-4*rp*t-m*t**2)/d;
console.log('t=',t,'w=',w,'m=',m,'d=',d,'x0=',x0,'x1=',x1,'x2=',x2,'y1=',y1,'y2=',y2);
  //Lowpass to lopass or lowpass to highpass transform
  if (lh==1) {k=-Math.cos(w/2+1/2)/Math.cos(w/2-1/2)}
  else if (lh==0) {k=Math.sin(1/2-w/2)/Math.sin(1/2+w/2)};
  d=1+y1*k-y2*k**2;
  c.a0=(x0-x1*k+x2*k**2)/d;
  c.a1=(-2*x0*k+x1+x1*k**2-2*x2*k)/d;
  c.a2=(x0*k**2-x1*k+x2)/d;
  c.b1=(2*k+y1+y1*k**2-2*y2*k)/d;
  c.b2=(-(k**2)-y1*k+y2)/d;
  if (lh==1){
    c.a1=-c.a1;
    c.b1=-c.b1;
  }

console.log('c=',c);
console.log('exit getpolepair');
  return c;
}



function chebyshev1IIR(fc,lh,pr,np){
  //fc - cutoff frequency 0.0-0.5;
  //lh=0 low pass filter, lh=1 - high pass filter
  //pr - percent ripple 0-29
  //np - number of poles (even number from 2 to 20)

  let a=[]; //a[0] ,...a[21] coefficients
  let b=[]; //b[1] ,...b[21] coefficients
  let ta=[]; //0-21
  let tb=[]; //0-21
  for (let i=0; i<23; i++) {
    a[i]=0;
    b[i]=0;
  }
  a[2]=1;
  b[2]=1;
  let c={a0:0,a2:0,a2:0,b1:0,b2:0};
  for (let p=1; p<np/2+1; p++){//loop for each pole pair
    c=getpolepair(fc,lh,pr,np,p);
console.log('c=',c);
    for (let i=0;i<23;i++){
      ta[i]=a[i];
      tb[i]=b[i];
    }

    for (let i=2;i<23;i++){
      a[i]=c.a0*ta[i]+c.a1*ta[i-1]+c.a2*ta[i-2];
      b[i]=tb[i]+c.b1*tb[i-1]+c.b2*tb[i-2];//b[i]=tb[i]-c.b1*tb[i-1]-c.b2*tb[i-2];
    }
  }
  b[2]=0;
  for (let i=0;i<21;i++) {//shifting the coefficients
    a[i]=a[i+2];
    b[i]=b[i+2];
  }
  let sa=0; //normalize the gain
  let sb=0;
  for (let i=0; i<21; i++) {
    if (lh==0) { //low pass
      sa=sa+a[i];
      sb=sb+b[i];
    } else if (lh==1){//high pass
      sa=sa+a[i]*(-1)**i;
      sb=sb+b[i]*(-1)**i;
    }
  }
  let gain=sa/(1-sb);
  for(let i=0;i<21;i++){
    a[i]=a[i]/gain;
  }
console.log('sa=',sa,'sb=',sb,'a=',a,'b=',b);
}




    const fd=512;//1024;  //sampling rate, Hz

    const buflen=512; //signal buffer length

    const canvas1_height = 512; //canvas height
    const ym1 = canvas1_height/2;
    const canvas_height = 256; //canvas height
    const ym=canvas_height/2;
    const canvas_width = 534;//1080;   //canvas width

    const signal_ampl = 80;//canvas_height/2-5-max_noise_ampl;
    const max_noise_ampl=2*signal_ampl;// 200%
    var noise_ampl=max_noise_ampl;//50;

    const isin=[];  //signal without noise
    const isign=[]; //signal with noise


    var f=(5/100)*fd; //signal frequency, Hz
    for (let i = 0; i < buflen; i++) isin[i] = signal_ampl*Math.cos(2*Math.PI*i*f/fd); //fill the signal buffer without noise

    const x=[];
    const y=[];
    const sp=[];

    const vertCubesMenu = {
      //texts:[],
      //bgcolor:0x440044,
      //fgcolor:'gold',
      canvas:[],
      ctx:[],


      textures:[],
      cubes:[],
      geometry:null,
      materials:[],
      tblrmaterial:null,
      previousSelectedCube:null,
      limits:[],
      x:0,
      y:0,
      z:0,
      dy:0,
      constructor:function(x,cyup,cydn,z,bgcolor,fgcolor,bgcolor1,texts,camera){
        this.limits=null;
        this.texts=texts;
        this.bgcolor=bgcolor;
        this.fgcolor=fgcolor;
        this.bgcolor1=bgcolor1;

        this.tblrmaterial = new THREE.MeshPhongMaterial({ color: 0x440044 }); // top,bottom,left,right
        this.previousSelectedCube=null;

        let hh=(cyup-cydn)/this.texts.length;
        let h=hh;
        if (h>1) h=1;
        for (let i=0; i<this.texts.length; i++)   {//create all textures
          this.canvas[i] = document.createElement('canvas'); //create a canvas
          this.ctx[i] = this.canvas[i].getContext('2d'); //create a canvas context
          this.canvas[i].width = 256;   //canvas width
          this.canvas[i].height = 256;  //canvas height
          this.drawCanvas(i,0);
          this.textures[i] = new THREE.CanvasTexture(this.canvas[i]);

          this.geometry = new THREE.BoxGeometry(1, h, h);//boxwidth,boxheight, boxdeepth
          this.materials[i] = new THREE.MeshPhongMaterial({map: this.textures[i]}); //make a material of the given texture
          this.cubes[i] = new THREE.Mesh(this.geometry, [
            this.materials[i],//Front texture
            this.tblrmaterial, // top
            this.tblrmaterial, // bottom
            this.tblrmaterial,//left texture
            this.materials[i],//front texture //back texture
            this.tblrmaterial,//right texture
          ]); //make a mesh (here - a cube) from the given materials and geometry

          this.cubes[i].position.x=x;
          this.cubes[i].position.y=cydn+h/2+i*hh;
          this.cubes[i].position.z=z;

          this.cubes[i].userData={
            mod  : 0,
            func : (mod)=>{this.drawCanvas(i,mod); this.cubes[i].userData.mod=mod; this.textures[i].needsUpdate=true;},

            pointerDown : (uv)=>{
//console.log('point=',point);
              if (this.previousSelectedCube) this.previousSelectedCube.userData.unselectTexture();
              if (this.cubes[i] != this.previousSelectedCube ) {
                this.cubes[i].userData.selectTexture();
                adjustParameterValueCube.drawParameter(i);
                this.previousSelectedCube = this.cubes[i];
              } else {
                this.previousSelectedCube = null;
                adjustParameterValueCube.clear();
              }
            },
            selectTexture   : ()=>{this.drawCanvas(i,1); this.textures[i].needsUpdate=true;},
            unselectTexture : ()=>{this.drawCanvas(i,0); this.textures[i].needsUpdate=true;},
          };

          camera.add(this.cubes[i]);
        }
        this.x=this.cubes[this.texts.length-1].position.x;
        this.z=this.cubes[this.texts.length-1].position.z;
        this.y=this.cubes[this.texts.length-1].position.y;
        this.dy=hh;
      },

      setParamLimits(limits){
        this.limits=limits; //[vmin,v,vmax,dv,units],...,[vmin,v,vmax,dv,units]
      },

      drawCanvas:function(i,mode){//mode=0 uses bgcolor and mode !=0 uses bgcolor1
        let canvas=this.canvas[i];
        let ctx=this.ctx[i];
        let strings=this.texts[i];
        ctx.beginPath();
        ctx.strokeStyle = this.fgcolor;//'gold';
        if (mode==0){
          ctx.fillStyle = this.bgcolor;//'#004444'; //'#333333'; //fill color
        } else {
          ctx.fillStyle = this.bgcolor1;//'#004444'; //'#333333'; //fill color
        }

        ctx.fillRect(1, 1, canvas.width-2*1, canvas.height-2*1); //fill rectangle
        ctx.strokeRect(8, 8, canvas.width-2*8, canvas.height-2*8);
        ctx.font = "40px Times";
        ctx.fillStyle = this.fgcolor;//'#888844'; //fill color '#333333'
        ctx.textAlign = "center";

        let n;
        if (strings.length%2==0) n=strings.length/2; else n=(strings.length-1)/2;
        if (strings.length%2==0) {
          for (let i=0; i<strings.length; i++)
          ctx.fillText(strings[i], canvas.width/2, canvas.height/2+25+(i-n)*50);
        }
        else {
          for (let i=0; i<strings.length; i++)
          ctx.fillText(strings[i], canvas.width/2, canvas.height/2+10+(i-n)*50);
        }
        ctx.arc(canvas.width/2, canvas.height/2, 120, 0, 2 * Math.PI); //x,y,radius, startAngle, endAngle
        ctx.stroke();
      }
    }

    //x,cyup,cydn,z,bgcolor,fgcolor,texts,camera
    vertCubesMenu.constructor(-3.6,2+0.05,-2+0.05,-7,'#004444','gold','#444400',[['Signal','frequency,','%Fs'],['Noise level','%'],['IIR filter','units'],['ddddd','eee','fffff','units']],camera);
    vertCubesMenu.setParamLimits([[0,5,50],[0,200,200],[5,8,10],[16,20,200]]);


    const sin2pii_buflen=[];
    const cos2pii_buflen=[];
    for (let i = 0; i < buflen; i++) {
      sin2pii_buflen[i] = Math.sin(2*Math.PI*i/buflen);
      cos2pii_buflen[i] = Math.cos(2*Math.PI*i/buflen);
    }

    //build a geometry
    const boxWidth = 2.5;
    const boxHeight = 1;
    const boxDepth = 2.5;


    const displaySpectrumCube = {
      bgcolor:0x440044,
      fgcolor:'gold',
      canvas:null,
      ctx:null,
      texture:null,
      cube:null,
      constructor:function(w,h,d,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,camera) {
        this.fgcolor=fgcolor;
        this.bgcolor=bgcolor;

        this.canvas = document.createElement('canvas'); //create a canvas
        let canvas=this.canvas;
        this.texture = new THREE.CanvasTexture(canvas);//create a texture based on this canvas;
        canvas.width = canvas_width;   //canvas width
        canvas.height = canvas_height;  //canvas height
        this.ctx = canvas.getContext('2d'); //create a canvas context
        let ctx=this.ctx;
/*
        ctx.font = "40px Times";
        ctx.strokeStyle = this.fgcolor;
        ctx.fillStyle = this.fgcolor;
        ctx.textAlign = "left";
        ctx.fillText("Signal frequency:", 20, this.canvas.height-25);
        ctx.fillText("Noise level:     ", 20, this.canvas.height-65);
*/
        ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
        ctx.strokeRect(0, 12, this.canvas.width-2*6, this.canvas.height-2*12);
        //ctx.beginPath();
        //ctx.moveTo(this.canvas.width/2-4,7);
        //ctx.lineTo(this.canvas.width/2-4,this.canvas.height-8);
        //ctx.stroke();
        ctx.fillStyle = this.bgcolor;
        this.drawSpectrum();
/*
        let material = new THREE.MeshPhongMaterial({map: this.texture}); //make a material of the given texture
        let material0 = new THREE.MeshPhongMaterial({ color: this.bgcolor }); // material with the given color
        let geometry = new THREE.BoxGeometry(w, h, d);
        this.cube = new THREE.Mesh(geometry, [
          material,//Front texture
          material,//back texture
          material0,//top material
          material0,// bottom
          material,//left texture
          material,//right texture
        ]); //make a mesh (here - a cube) from the given materials and geometry
        scene.add(this.cube);

        this.cube.position.x = x;
        this.cube.position.y = y;
        this.cube.position.z = z;
*/
        let geometry1 = new THREE.PlaneGeometry( w, h );
        let material1 = new THREE.MeshPhongMaterial( {map:this.texture} );
        let plane = new THREE.Mesh( geometry1, material1 );
        camera.add( plane );
        plane.position.x=x;
        plane.position.y=y;
        plane.position.z=z;
      },

      drawSpectrum:function() {
        let ctx=this.ctx;
        let w = this.canvas.width;

        //ctx.beginPath();
        ctx.clearRect(0, 0, w, canvas_height);
        ctx.fillStyle = this.bgcolor;
        ctx.strokeStyle = this.fgcolor;
ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
        ctx.fillRect(8+1, ym-signal_ampl, w-2*8-2, 2*signal_ampl); //fill rectangle

        for (let n = 0; n < buflen/2+1; n++) { //calculate signal harmonics (first part)
          x[n]=0;
          y[n]=0;
          for (let i = 0; i < buflen; i++) {
            x[n] = x[n] + isign[i]*cos2pii_buflen[(i*n) % buflen];
            y[n] = y[n] + isign[i]*sin2pii_buflen[(i*n) % buflen];
          }
          sp[n]=Math.sqrt(x[n]**2+y[n]**2)*4/buflen;
        }
        for (let n = buflen/2+1; n < buflen; n++) {//signal harmonics (second part)
          x[n]=x[buflen-n];
          y[n]=-y[buflen-n];
          sp[n]=Math.sqrt(x[n]**2+y[n]**2)*4/buflen;//calculate AF spectrum
        }

        ctx.beginPath();
        ctx.moveTo(12,ym); //draw signal with noise spectrum
        ctx.lineTo(buflen,ym);
        for (let i = 0; i < buflen; i++) {
          ctx.moveTo(11+i,ym);
          ctx.lineTo(11+i,ym-sp[i]/2);
        }
        ctx.stroke();
      }
    }

    class tdisplaySignalCube {
/*
      bgcolor:0x440044,
      fgcolor:'gold',
      canvas:null,
      ctx:null,
      texture:null,
  */
      constructor(w,h,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,camera) {
        this.fgcolor=fgcolor;
        this.bgcolor=bgcolor;

        this.canvas = document.createElement('canvas'); //create a canvas
        let canvas=this.canvas;
        this.texture = new THREE.CanvasTexture(canvas);//create a texture based on this canvas;
        canvas.width = canvas_width;   //canvas width
        canvas.height = canvas_height;  //canvas height
        this.ctx = canvas.getContext('2d'); //create a canvas context
        let ctx=this.ctx;
        ctx.strokeStyle = this.fgcolor;
/*
        ctx.font = "40px Times";
        ctx.strokeStyle = this.fgcolor;
        ctx.fillStyle = this.fgcolor;
        ctx.textAlign = "left";
        ctx.fillText("Signal frequency:", 20, this.canvas.height-25);
        ctx.fillText("Noise level:     ", 20, this.canvas.height-65);
*/
        //ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
        //ctx.strokeRect(1, 12, this.canvas.width/2-2*6, this.canvas.height-2*12);

        //ctx.beginPath();
        //ctx.moveTo(this.canvas.width/2-4,7);
        //ctx.lineTo(this.canvas.width/2-4,this.canvas.height-8);
        //ctx.stroke();
        ctx.fillStyle = this.bgcolor;
        this.drawSignal();
/*
        let material = new THREE.MeshPhongMaterial({map: this.texture}); //make a material of the given texture
        let material0 = new THREE.MeshPhongMaterial({ color: this.bgcolor }); // material with the given color
        let geometry = new THREE.BoxGeometry(w, h, d);
        this.cube = new THREE.Mesh(geometry, [
          material,//Front texture
          material,//back texture
          material0,//top material
          material0,// bottom
          material,//left texture
          material,//right texture
        ]); //make a mesh (here - a cube) from the given materials and geometry
//        scene.add(this.cube);
        this.cube.position.x = x;
        this.cube.position.y = y;
        this.cube.position.z = z;
*/
        let geometry1 = new THREE.PlaneGeometry( w, h );
        let material1 = new THREE.MeshPhongMaterial( {map:this.texture} );
        let plane = new THREE.Mesh( geometry1, material1 );
        camera.add( plane );
        plane.position.x=x;
        plane.position.y=y;
        plane.position.z=z;
        //plane.scale.set(4,2,1);


/*
        let material1 = new THREE.SpriteMaterial( { map: this.texture } );
        const sprite = new THREE.Sprite( material1 );
        scene.add( sprite );
        sprite.center.y=-1;
        sprite.scale.set(2,2,2);
        sprite.color='blue';
*/
      }

      drawSignal() {
        let ctx = this.ctx;
        let w = this.canvas.width;
        let h = this.canvas.height;
        ctx.clearRect(0, 0, w, h);
        ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);
        ctx.fillRect(8+1, ym1-signal_ampl, w-2*8-2, 2*signal_ampl); //fill rectangle

        ctx.beginPath();
        ctx.moveTo(12,ym1);
        for (let i = 0; i < buflen; i++) {
          isign[i]=isin[i] + Math.floor((0.5-Math.random()) * 2*noise_ampl);//add noise th the signal
          ctx.lineTo((i+10),ym1 - isign[i]); //draw the signal with noise
        }
        ctx.stroke();
      }
    }

class tdisplayParameterValuesrect {
  constructor (w,h,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,camera) {
    this.fgcolor=fgcolor;
    this.bgcolor=bgcolor;

    this.canvas = document.createElement('canvas'); //create a canvas
    let canvas=this.canvas;
    canvas.width = canvas_width;   //canvas width
    canvas.height = canvas_height;  //canvas height
    this.ctx = canvas.getContext('2d'); //create a canvas context
    let ctx=this.ctx;
    this.texture = new THREE.CanvasTexture(canvas);//create a texture based on this canvas;
    //ctx.beginPath();
    ctx.fillStyle = this.bgcolor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = "40px Times";
    ctx.strokeStyle = this.fgcolor;
    ctx.fillStyle = this.fgcolor;
    ctx.textAlign = "left";
    ctx.fillText("Signal frequency:", 20, this.canvas.height-25);
    ctx.fillText("Noise level:     ", 20, this.canvas.height-65);

    ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);

    ctx.fillStyle = this.bgcolor;

    let geometry1 = new THREE.PlaneGeometry( w, h );
    let material1 = new THREE.MeshPhongMaterial( {map:this.texture} );
    let plane = new THREE.Mesh( geometry1, material1 );
    camera.add( plane );
    plane.position.x=x;
    plane.position.y=y;
    plane.position.z=z;
  }
}

    class tadjustParameterValueCube {
/*
      bgcolor:'#440044',
      fgcolor:'gold',
      fgcolor1:'#440044',
      canvas:null,
      ctx:null,
      texture:null,
      cubeindex:undefined,
      plane:null,
      boxwidth:0,
*/
      constructor(w,h,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,camera) {
        this.cubeindex=undefined;

        this.fgcolor=fgcolor;
        this.bgcolor=bgcolor;
        this.fgcolor1='#666600';

        this.canvas = document.createElement('canvas'); //create a canvas
        let canvas=this.canvas;
        canvas.width = canvas_width*2;
        canvas.height = canvas_height;  //canvas height

        this.ctx = canvas.getContext('2d'); //create a canvas context
        let ctx=this.ctx;

        this.texture = new THREE.CanvasTexture(canvas);//create a texture based on this canvas;
        ctx.fillStyle = this.bgcolor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = this.fgcolor;
        ctx.strokeRect(8, 8, this.canvas.width-2*8, this.canvas.height-2*8);

        ctx.font = "40px Times";

        let geometry1 = new THREE.PlaneGeometry( w, h );
        this.boxwidth=w;
        let material1 = new THREE.MeshPhongMaterial( {map:this.texture} );
        let plane = new THREE.Mesh( geometry1, material1 );
        camera.add( plane );
        plane.position.x=x;
        plane.position.y=y;
        plane.position.z=z;
        this.plane=plane;
        this.cubeindex=undefined;

        plane.userData={
          pointerDown : (uv)=>{
          //console.log('point=',point);
          if (this.cubeindex !== undefined) {
            let lim=vertCubesMenu.limits[this.cubeindex];
            lim[1]=lim[0]+(lim[2]-lim[0])*uv.x;
            vertCubesMenu.limits[this.cubeindex]=lim;

            console.log('pointewrDown lim=',lim,' uv.x=',uv.x);
            switch(this.cubeindex) {
              case 0:
                f=fd*lim[1]/100;
                //console.log('f=',f);
                for (let i = 0; i < buflen; i++) isin[i] = signal_ampl*Math.cos(2*Math.PI*i*f/fd);
        //getpolepair(0.1,0,0,4,1);//getpolepair(0.1,1,10,4,2);//getpolepair(fc,lh,pr,np,p)
        chebyshev1IIR(0.01,1,0.5,2);//chebyshev1IIR(fc,lh,pr,np);
                break;
              case 1:
                noise_ampl=signal_ampl*lim[1]/100;
                // code block
                break;
              default:
                // code block
            }
            this.drawParameter(this.cubeindex);
//console.log('parameter index=',this.cubeindex,'this.canvas.getBoundingClientRect()=', this.canvas.getBoundingClientRect());
            } else console.log('parameter not selected!!!');
          },
        }

      }

      drawParameter(i){
        this.cubeindex=i;//selected parameted has index i
//console.log('enter drawParameter');

        let ctx=this.ctx;
        ctx.fillStyle = this.bgcolor;
        ctx.fillRect(8+1, 8+1, this.canvas.width-2*8-2, this.canvas.height-2*8-2);//clear the inside rectangular zone;
        let strings = vertCubesMenu.texts[i];
        let s='';
        strings.forEach((string, ndx) => {
          s=s+' '+string;
        });
        ctx.textAlign = "center";
        ctx.fillStyle = this.fgcolor;
        ctx.fillText(s, this.canvas.width/2, 50); //output parameter name on the rectangle

        let lim=vertCubesMenu.limits[i];
  console.log('i=',i,'vertCubesMenu.limits[i]=',vertCubesMenu.limits[i]);
        ctx.fillStyle = this.fgcolor1;
        ctx.textAlign = "left";
        ctx.fillText(lim[0], 11, 50+40); //output minimal value
        ctx.textAlign = "right";
        ctx.fillText(lim[2], this.canvas.width-11, 50+40);//output maximal value

        ctx.fillStyle = this.fgcolor;
        let x=(this.canvas.width-2*8-4)*(lim[1]-lim[0])/(lim[2]-lim[0]);
//console.log('x=',x,' lim=',lim);
        x=Math.round(x);
//console.log('x=',x);
        ctx.fillRect(8+2, 100, x, this.canvas.height-2*8-50-100);
        if ( x < this.canvas.width/2 ) {ctx.textAlign = "left"}
        else ctx.textAlign = "right";
        ctx.fillText(Math.round(lim[1]*10)/10, x+8, this.canvas.height-20);

        this.texture.needsUpdate=true;
      }
      clear(){
        this.cubeindex=undefined; //parameter not selected

        let ctx=this.ctx;
        ctx.fillStyle = this.bgcolor;
        ctx.fillRect(8+1, 8+1, this.canvas.width-2*8-2, this.canvas.height-2*8-2);
        this.texture.needsUpdate=true;
      }
    }

    const displaySignalCube = new tdisplaySignalCube(boxWidth, boxHeight*2, vertCubesMenu.x+vertCubesMenu.dy+2*boxWidth, vertCubesMenu.y-vertCubesMenu.dy/2, vertCubesMenu.z,'#440044','gold',canvas_width,canvas1_height,camera);
  //  displayParameterValuesrect.constructor(boxWidth,boxHeight*2,   vertCubesMenu.x+vertCubesMenu.dy+boxWidth, vertCubesMenu.y-vertCubesMenu.dy/2, vertCubesMenu.z,'#440044','gold',canvas_width,canvas1_height,camera);
    const displayParameterValuesrect = new tdisplayParameterValuesrect(boxWidth,boxHeight*2,   vertCubesMenu.x+vertCubesMenu.dy+boxWidth, vertCubesMenu.y-vertCubesMenu.dy/2, vertCubesMenu.z,'#440044','gold',canvas_width,canvas1_height,camera);

    displaySpectrumCube.constructor(boxWidth, boxHeight, boxDepth, vertCubesMenu.x+vertCubesMenu.dy+2*boxWidth, vertCubesMenu.y-4*vertCubesMenu.dy/2, vertCubesMenu.z,'#440044','gold',canvas_width,canvas_height,camera);
  //w,h,d,x,y,z,bgcolor,fgcolor,canvas_width,canvas_height,string,vmin,v,vmax,units,scene
    const adjustParameterValueCube = new tadjustParameterValueCube(boxWidth*2, boxHeight, vertCubesMenu.x+vertCubesMenu.dy + 3*boxWidth/2, vertCubesMenu.y-6*vertCubesMenu.dy/2, vertCubesMenu.z,'#004444','gold',canvas_width,canvas_height,camera);


    class PickHelper {
      constructor() {
        this.raycaster = new THREE.Raycaster();
        this.selectedObject = null; // the former selected object
      }

      pick(normalizedPosition, scene, camera/*, time*/) {
        this.raycaster.setFromCamera(normalizedPosition, camera);  // cast a ray through the frustum
        // get the list of objects the ray intersected
        const intersectedObjects = this.raycaster.intersectObjects(camera.children);
  console.log('uv=',intersectedObjects[0].object);
        if (intersectedObjects.length) intersectedObjects[0].object.userData.pointerDown(intersectedObjects[0].uv);
      }
    }

    const pickPosition = {x: 0, y: 0};
    const pickHelper = new PickHelper();

    function getCanvasRelativePosition(event) {
      const rect = canvas.getBoundingClientRect();//gets left, top, right, bottom, x, y, width, height of the document canvas
      return {
        x: (event.clientX - rect.left) * canvas.width  / rect.width,
        y: (event.clientY - rect.top ) * canvas.height / rect.height,
      };
    }

    function setPickPosition(event) {
      const pos = getCanvasRelativePosition(event);
      pickPosition.x = (pos.x / canvas.width ) *  2 - 1;
      pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y
      //pickPosition is now in normalized form (between -1 and 1 and the left bottom point is (-1,-1) while the top right point is (1,1))
    }
/*
    function clearPickPosition() {
      // unlike the mouse which always has a position
      // if the user stops touching the screen we want
      // to stop picking. For now we just pick a value
      // unlikely to pick something
      pickPosition.x = -100000;
      pickPosition.y = -100000;
    }

    window.addEventListener('mouseenter', setPickPosition);   //
    window.addEventListener('touchstart', (event) => {       //'touchstart' event occurs when a finger is placed on the window
      event.preventDefault(); // prevent the window from scrolling
      setPickPosition(event.touches[0]);
    }, {passive: false});
*/
/*
var cursorX;
var cursorY;
document.onmousedown = function(e){
    cursorX = e.pageX;
    cursorY = e.pageY;
    console.log(cursorX,' ',cursorY)
*/
    window.addEventListener('pointerdown', (event) => {        //'touchmove' event occurs when a finger is dragged across the window
      setPickPosition(event);
      pickHelper.pick(pickPosition, scene, camera/*, time*/);
 //console.log('pointerdown',event.pageX,' ',event.pageY,'pickPosition=',pickPosition);
    });



    //window.addEventListener('mousemove', setPickPosition);   //'mousemove'event occurs when the pointer is moving while it is over the window
    window.addEventListener('touchstart', (event) => {        //'touchmove' event occurs when a finger is dragged across the window
      setPickPosition(event.touches[0]);
      pickHelper.pick(pickPosition, scene, camera/*, time*/);
    });
/*
    //window.addEventListener('mouseout',   clearPickPosition);   //'mouseout' event occurs when a user moves the mouse pointer out of the window, or out of one of its children
    window.addEventListener('mouseleave', clearPickPosition);  //'mouseleave' event occurs when the pointer is moved out of the window
    window.addEventListener('mouseout',   clearPickPosition);
    window.addEventListener('touchend',   clearPickPosition);  //'touchend' event occurs when a finger is removed from the window
*/

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      const width = window.innerWidth; //canvas.clientWidth;
      const height = window.innerWidth * 0.5; //canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, true);
      }
      return needResize;
    }

//    controls.addEventListener('change', (event) => {console.log('change'); });
    controls.addEventListener('start', (event) => {
      //console.log("Controls Start Event", event)
    });
//    controls.addEventListener('end', (event) => console.log("Controls End Event"));

    function render(time) { //render function rotates cubes and renderer displays them on screen
      time *= 0.001;  // convert time to seconds

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      displaySignalCube.drawSignal();
      displaySignalCube.texture.needsUpdate=true;
      displaySpectrumCube.drawSpectrum()
      displaySpectrumCube.texture.needsUpdate=true;
/*
      cubes.forEach((cube, ndx) => {
        const speed = 0.2 + ndx * .00125;
        const rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
      });

      cameraPole.rotation.y = -time * 0.05; //rotate camera
      cubesPole.rotation.y = -time * 0.15; //rotate c3 cubes
*/

      renderer.render(scene, camera); //renderer renders the given scene using given camera
      requestAnimationFrame(render);  //requests a new frame using the render function and exits the function
    }

    requestAnimationFrame(render); //requests the first frame using the render function

  }

  main();

  </script>

<!--
  <h1> <a href="https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html"> https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html </a> threejs fundamentals </h1>
-->
  <canvas id="myCanvas">  </canvas>

</body>


</html>
